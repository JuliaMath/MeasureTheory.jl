<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeasureBase ¬∑ MeasureTheory.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cscherrer.github.io/MeasureTheory.jl/api_measurebase/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MeasureTheory.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adding/">Adding a new measure</a></li><li><a class="tocitem" href="../affine/">Affine transformations</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>MeasureBase</a></li><li><a class="tocitem" href="../api_measuretheory/">MeasureTheory</a></li><li><a class="tocitem" href="../api_index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>MeasureBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MeasureBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cscherrer/MeasureTheory.jl/blob/master/docs/src/api_measurebase.md#L" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MeasureBase-API"><a class="docs-heading-anchor" href="#MeasureBase-API">MeasureBase API</a><a id="MeasureBase-API-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureBase-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.Density" href="#MeasureBase.Density"><code>MeasureBase.Density</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Density{M,B}
    Œº::M
    base::B
end</code></pre><p>For measures Œº and ŒΩ with Œº‚â™ŒΩ, the density of Œº with respect to ŒΩ (also called the Radon-Nikodym derivative dŒº/dŒΩ) is a function f defined on the support of ŒΩ with the property that for any measurable a ‚äÇ supp(ŒΩ), Œº(a) = ‚à´‚Çê f dŒΩ.</p><p>Because this function is often difficult to express in closed form, there are many different ways of computing it. We therefore provide a formal representation to allow comptuational flexibilty.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.DensityMeasure" href="#MeasureBase.DensityMeasure"><code>MeasureBase.DensityMeasure</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DensityMeasure{F,B} &lt;: AbstractMeasure
    density :: F
    base    :: B
end</code></pre><p>A <code>DensityMeasure</code> is a measure defined by a density with respect to some other &quot;base&quot; measure </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.Likelihood" href="#MeasureBase.Likelihood"><code>MeasureBase.Likelihood</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Likelihood(k::AbstractKleisli, x)</code></pre><p>&quot;Observe&quot; a value <code>x</code>, yielding a function from the parameters to ‚Ñù.</p><p>Likelihoods are most commonly used in conjunction with an existing <em>prior</em> measure to yield a new measure, the <em>posterior</em>. In Bayes&#39;s Law, we have</p><p><span>$P(Œ∏|x) ‚àù P(Œ∏) P(x|Œ∏)$</span></p><p>Here <span>$P(Œ∏)$</span> is the prior. If we consider <span>$P(x|Œ∏)$</span> as a function on <span>$Œ∏$</span>, then it is called a likelihood.</p><p>Since measures are most commonly manipulated using <code>density</code> and <code>logdensity</code>, it&#39;s awkward to commit a (log-)likelihood to using one or the other. To evaluate a <code>Likelihood</code>, we therefore use <code>density</code> or <code>logdensity</code>, depending on the circumstances. In the latter case, it is of course acting as a log-density.</p><p>For example,</p><pre><code class="nohighlight hljs">julia&gt; ‚Ñì = Likelihood(Normal{(:Œº,)}, 2.0)
Likelihood(Normal{(:Œº,), T} where T, 2.0)

julia&gt; density_def(‚Ñì, (Œº=2.0,))
1.0

julia&gt; logdensity_def(‚Ñì, (Œº=2.0,))
-0.0</code></pre><p>If, as above, the measure includes the parameter information, we can optionally leave it out of the second argument in the call to <code>density</code> or <code>logdensity</code>. </p><pre><code class="nohighlight hljs">julia&gt; density_def(‚Ñì, 2.0)
1.0

julia&gt; logdensity_def(‚Ñì, 2.0)
-0.0</code></pre><p>With several parameters, things work as expected:</p><pre><code class="nohighlight hljs">julia&gt; ‚Ñì = Likelihood(Normal{(:Œº,:œÉ)}, 2.0)
Likelihood(Normal{(:Œº, :œÉ), T} where T, 2.0)

julia&gt; logdensity_def(‚Ñì, (Œº=2, œÉ=3))
-1.0986122886681098

julia&gt; logdensity_def(‚Ñì, (2,3))
-1.0986122886681098

julia&gt; logdensity_def(‚Ñì, [2, 3])
-1.0986122886681098</code></pre><hr/><pre><code class="nohighlight hljs">Likelihood(M&lt;:ParameterizedMeasure, constraint::NamedTuple, x)</code></pre><p>In some cases the measure might have several parameters, and we may want the (log-)likelihood with respect to some subset of them. In this case, we can use the three-argument form, where the second argument is a constraint. For example,</p><pre><code class="nohighlight hljs">julia&gt; ‚Ñì = Likelihood(Normal{(:Œº,:œÉ)}, (œÉ=3.0,), 2.0)
Likelihood(Normal{(:Œº, :œÉ), T} where T, (œÉ = 3.0,), 2.0)</code></pre><p>Similarly to the above, we have</p><pre><code class="nohighlight hljs">julia&gt; density_def(‚Ñì, (Œº=2.0,))
0.3333333333333333

julia&gt; logdensity_def(‚Ñì, (Œº=2.0,))
-1.0986122886681098

julia&gt; density_def(‚Ñì, 2.0)
0.3333333333333333

julia&gt; logdensity_def(‚Ñì, 2.0)
-1.0986122886681098</code></pre><hr/><p>Finally, let&#39;s return to the expression for Bayes&#39;s Law, </p><p><span>$P(Œ∏|x) ‚àù P(Œ∏) P(x|Œ∏)$</span></p><p>The product on the right side is computed pointwise. To work with this in MeasureBase, we have a &quot;pointwise product&quot; <code>‚äô</code>, which takes a measure and a likelihood, and returns a new measure, that is, the unnormalized posterior that has density <span>$P(Œ∏) P(x|Œ∏)$</span> with respect to the base measure of the prior.</p><p>For example, say we have</p><pre><code class="nohighlight hljs">Œº ~ Normal()
x ~ Normal(Œº,œÉ)
œÉ = 1</code></pre><p>and we observe <code>x=3</code>. We can compute the posterior measure on <code>Œº</code> as</p><pre><code class="nohighlight hljs">julia&gt; post = Normal() ‚äô Likelihood(Normal{(:Œº, :œÉ)}, (œÉ=1,), 3)
Normal() ‚äô Likelihood(Normal{(:Œº, :œÉ), T} where T, (œÉ = 1,), 3)

julia&gt; logdensity_def(post, 2)
-2.5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.PrimitiveMeasure" href="#MeasureBase.PrimitiveMeasure"><code>MeasureBase.PrimitiveMeasure</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveMeasure &lt;: AbstractMeasure end</code></pre><p>In the MeasureTheory ecosystem, a <em>primitive</em> measure is a measure for which the definition and construction do not depend on any other measure. Primitive measures satisfy the following laws:</p><pre><code class="nohighlight hljs">basemeasure(Œº::PrimitiveMeasure) = Œº

logdensity_def(Œº::PrimitiveMeasure, x) = 0.0

logdensity_def(Œº::M, ŒΩ::M, x) where {M&lt;:PrimitiveMeasure} = 0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.SuperpositionMeasure" href="#MeasureBase.SuperpositionMeasure"><code>MeasureBase.SuperpositionMeasure</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SuperpositionMeasure{X,NT} &lt;: AbstractMeasure
    components :: NT
end</code></pre><p>Superposition of measures is analogous to mixture distributions, but (because measures need not be normalized) requires no scaling. The superposition of two measures Œº and ŒΩ can be more concisely written as Œº + ŒΩ. Superposition measures satisfy</p><pre><code class="nohighlight hljs">basemeasure(Œº + ŒΩ) == basemeasure(Œº) + basemeasure(ŒΩ)</code></pre><p class="math-container">\[    \begin{aligned}\frac{\mathrm{d}(\mu+\nu)}{\mathrm{d}(\alpha+\beta)} &amp; =\frac{f\,\mathrm{d}\alpha+g\,\mathrm{d}\beta}{\mathrm{d}\alpha+\mathrm{d}\beta}\\
     &amp; =\frac{f\,\mathrm{d}\alpha}{\mathrm{d}\alpha+\mathrm{d}\beta}+\frac{g\,\mathrm{d}\beta}{\mathrm{d}\alpha+\mathrm{d}\beta}\\
     &amp; =\frac{f}{1+\frac{\mathrm{d}\beta}{\mathrm{d}\alpha}}+\frac{g}{\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}+1}\\
     &amp; =\frac{f}{1+\left(\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}\right)^{-1}}+\frac{g}{\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}+1}\ .
    \end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{AbstractMeasure, Any}" href="#Base.:|-Tuple{AbstractMeasure, Any}"><code>Base.:|</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(m::AbstractMeasure) | constraint</code></pre><p>Return a new measure by constraining <code>m</code> to satisfy <code>constraint</code>.</p><p>Note that the form of <code>constraint</code> will vary depending on the structure of a given measure. For example, a measure over <code>NamedTuple</code>s may allow <code>NamedTuple</code> constraints, while another may require <code>constraint</code> to be a predicate or a function returning a real number (in which case the constraint could be considered as the zero-set of that function). </p><p>At the time of this writing, invariants required of this function are not yet settled. Specifically, there&#39;s the question of normalization. It&#39;s common for conditional distributions to be normalized, but this can often not be expressed in closed form, and can be very expensive to compute. For more general measures, the notion of normalization may not even make sense.</p><p>Because of this, this interface is not yet stable, and users should expect upcoming changes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DensityInterface.logdensityof-Tuple{AbstractMeasure, Any}" href="#DensityInterface.logdensityof-Tuple{AbstractMeasure, Any}"><code>DensityInterface.logdensityof</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logdensityof(m::AbstractMeasure, x)</code></pre><p>Compute the log-density of the measure <code>m</code> at <code>x</code>. Density is always relative, but <code>DensityInterface.jl</code> does not account for this. For compatibility with this, <code>logdensityof</code> for a measure is always implicitly relative to <a href="#MeasureBase.rootmeasure-Tuple{Any}"><code>rootmeasure(x)</code></a>. </p><p><code>logdensityof</code> works by first computing <code>insupport(m, x)</code>. If this is true, then <code>unsafe_logdensityof</code> is called. If <code>insupport(m, x)</code> is known to be <code>true</code>, it can be a little faster to directly call <code>unsafe_logdensityof(m, x)</code>. </p><p>To compute log-density relative to <code>basemeasure(m)</code> or <em>define</em> a log-density (relative to <code>basemeasure(m)</code> or another measure given explicitly), see <code>logdensity_def</code>. </p><p>To compute a log-density relative to a specific base-measure, see <code>logdensity_rel</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.:‚Ü£-Tuple{Any, Any}" href="#MeasureBase.:‚Ü£-Tuple{Any, Any}"><code>MeasureBase.:‚Ü£</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>If </p><ul><li>Œº is an <code>AbstractMeasure</code> or satisfies the Measure interface, and</li><li>k is a function taking values from the support of Œº and returning a measure</li></ul><p>Then <code>Œº ‚Ü£ k</code> is a measure, called a <em>monadic bind</em>. In a probabilistic programming language like Soss.jl, this could be expressed as</p><p>Note that bind is usually written <code>&gt;&gt;=</code>, but this symbol is unavailable in Julia.</p><pre><code class="nohighlight hljs">bind = @model Œº,k begin 
    x ~ Œº
    y ~ k(x)
    return y
end</code></pre><p>See also <code>bind</code> and <code>Bind</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.:‚äó-Tuple{Vararg{AbstractMeasure}}" href="#MeasureBase.:‚äó-Tuple{Vararg{AbstractMeasure}}"><code>MeasureBase.:‚äó</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚äó(Œºs::AbstractMeasure...)</code></pre><p><code>‚äó</code> is a binary operator for building product measures. This satisfies the law</p><pre><code class="nohighlight hljs">    basemeasure(Œº ‚äó ŒΩ) == basemeasure(Œº) ‚äó basemeasure(ŒΩ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.basekleisli" href="#MeasureBase.basekleisli"><code>MeasureBase.basekleisli</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>For any <code>k::Kleisli</code>, <code>basekleisli</code> is expected to satisfy</p><pre><code class="nohighlight hljs">basekleisli(k)(p) == (basemeasure ‚àò k)(p)</code></pre><p>The main purpose of <code>basekleisli</code> is to make it efficient to compute</p><pre><code class="nohighlight hljs">basemeasure(d::ProductMeasure) = productmeasure(basekleisli(d.f), d.xs)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.basemeasure_sequence-Tuple{M} where M" href="#MeasureBase.basemeasure_sequence-Tuple{M} where M"><code>MeasureBase.basemeasure_sequence</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemeasure_sequence(m)</code></pre><p>Construct the longest <code>Tuple</code> starting with <code>m</code> having each term as the base measure of the previous term, and with no repeated entries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.commonbase-Union{Tuple{T}, Tuple{Any, Any, Type{T}}} where T" href="#MeasureBase.commonbase-Union{Tuple{T}, Tuple{Any, Any, Type{T}}} where T"><code>MeasureBase.commonbase</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commonbase(Œº, ŒΩ, T) -&gt; Tuple{StaticInt{i}, StaticInt{j}}</code></pre><p>Find minimal (with respect to their sum) <code>i</code> and <code>j</code> such that there is a method</p><pre><code class="nohighlight hljs">logdensity_def(basemeasure_sequence(Œº)[i], basemeasure_sequence(ŒΩ)[j], ::T)</code></pre><p>This is used in <code>logdensity_rel</code> to help make that function efficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.insupport" href="#MeasureBase.insupport"><code>MeasureBase.insupport</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inssupport(m, x)
insupport(m)</code></pre><p><code>insupport(m,x)</code> computes whether <code>x</code> is in the support of <code>m</code>.</p><p><code>insupport(m)</code> returns a function, and satisfies</p><pre><code class="nohighlight hljs">insupport(m)(x) == insupport(m, x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.kleisli" href="#MeasureBase.kleisli"><code>MeasureBase.kleisli</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kleisli(f, M)
kleisli((f1, f2, ...), M)</code></pre><p><code>kleisli</code> was originally called <code>kernel</code>, as in a <em>Markov kernel</em>. Such a kernel can be considered to map each value in its domain to a probability measure.</p><p>In the context of MeasureTheory, the codomain is not required to be a <em>probability</em> measure; any measure will do. This makes &quot;Markov&quot; not really fit, since the map need not be Markovian.</p><p>This leaves us with &quot;kernel&quot;, which can mean too wide a range of things to be useful in such a general context as measure theory. See for example https://github.com/JuliaGaussianProcesses/KernelFunctions.jl for one common use of this term.</p><p>We solve this problem by changing to a term from an even more general context. In category theory, a <em>Kleisli arrow</em> is a function taking monadic values. Since measures comprise a monad, our use is a special case of this.</p><p>A kleisli <code>Œ∫ = kleisli(f, m)</code> returns a wrapper around a function <code>f</code> giving the parameters for a measure of type <code>M</code>, such that <code>Œ∫(x) = M(f(x)...)</code> respective <code>Œ∫(x) = M(f1(x), f2(x), ...)</code></p><p>If the argument is a named tuple <code>(;a=f1, b=f1)</code>, <code>Œ∫(x)</code> is defined as <code>M(;a=f(x),b=g(x))</code>.</p><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Markov_kernel</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.logdensity_def" href="#MeasureBase.logdensity_def"><code>MeasureBase.logdensity_def</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>logdensity_def</code> is the standard way to define a log-density for a new measure. Note that this definition does not include checking for membership in the support; this is instead checked using <code>insupport</code>. <code>logdensity_def</code> is a low-level function, and should typically not be called directly. See <code>logdensityof</code> for more information and other alternatives.</p><hr/><pre><code class="nohighlight hljs">logdensity_def(m, x)</code></pre><p>Compute the log-density of the measure m at the point <code>x</code>, relative to <code>basemeasure(m)</code>, and assuming <code>insupport(m, x)</code>.</p><hr/><pre><code class="nohighlight hljs">logdensity_def(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at the point <code>x</code>, assuming <code>insupport(m1, x)</code> and <code>insupport(m2, x)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}" href="#MeasureBase.logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}"><code>MeasureBase.logdensity_rel</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logdensity_rel(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at <code>x</code>. This function checks whether <code>x</code> is in the support of <code>m1</code> or <code>m2</code> (or both, or neither). If <code>x</code> is known to be in the support of both, it can be more efficient to call <code>unsafe_logdensity_rel</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.paramnames" href="#MeasureBase.paramnames"><code>MeasureBase.paramnames</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>paramnames(Œº)</code> returns the names of the parameters of <code>Œº</code>. This is equivalent to </p><pre><code class="nohighlight hljs">paramnames(Œº) == (keys ‚àò params)(Œº)</code></pre><p>but depends only on the type. In particular, the default implementation is</p><pre><code class="nohighlight hljs">paramnames(Œº::M) where {M} = paramnames(M)</code></pre><p>New <code>ParameterizedMeasure</code>s will automatically have a <code>paramnames</code> method. For other measures, this method is optional, but can be added by defining</p><pre><code class="nohighlight hljs">paramnames(::Type{M}) where {M} = ...</code></pre><p>See also <code>params</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.params" href="#MeasureBase.params"><code>MeasureBase.params</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>params(Œº)</code> returns the parameters of a measure <code>Œº</code>, as a <code>NamedTuple</code>. The default method is</p><pre><code class="nohighlight hljs">params(Œº) = NamedTuple()</code></pre><p>See also <code>paramnames</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.proxy" href="#MeasureBase.proxy"><code>MeasureBase.proxy</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>function proxy end</p><p>It&#39;s often useful to delegate methods like <code>logdensity</code> and <code>basemeasure</code> to those of a different measure. For example, a <code>Normal{(:Œº,:œÉ)}</code> is equivalent to an affine transformation of a <code>Normal{()}</code>.</p><p>We <em>could</em> just have calls like <code>Normal(Œº=2,œÉ=4)</code> directly construct a transformed measure, but this would make dispatch awkward.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.rebase-Tuple{Any, Any}" href="#MeasureBase.rebase-Tuple{Any, Any}"><code>MeasureBase.rebase</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebase(Œº, ŒΩ)</code></pre><p>Express <code>Œº</code> in terms of a density over <code>ŒΩ</code>. Satisfies</p><pre><code class="nohighlight hljs">basemeasure(rebase(Œº, ŒΩ)) == ŒΩ
density(rebase(Œº, ŒΩ)) == ùíπ(Œº,ŒΩ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.rootmeasure-Tuple{Any}" href="#MeasureBase.rootmeasure-Tuple{Any}"><code>MeasureBase.rootmeasure</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootmeasure(Œº::AbstractMeasure)</code></pre><p>It&#39;s sometimes important to be able to find the fix point of a measure under <code>basemeasure</code>. That is, to start with some measure and apply <code>basemeasure</code> repeatedly until there&#39;s no change. That&#39;s what this does.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.schema" href="#MeasureBase.schema"><code>MeasureBase.schema</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schema(::Type)</code></pre><p><code>schema</code> turns a type into a value that&#39;s easier to work with. Example:     julia&gt; nt = (a=(b=[1,2],c=(d=[3,4],e=[5,6])),f=[7,8]);     julia&gt; NT = typeof(nt)     NamedTuple{(:a, :f),Tuple{NamedTuple{(:b, :c),Tuple{Array{Int64,1},NamedTuple{(:d, :e),Tuple{Array{Int64,1},Array{Int64,1}}}}},Array{Int64,1}}}     julia&gt; schema(NT)     (a = (b = Array{Int64,1}, c = (d = Array{Int64,1}, e = Array{Int64,1})), f = Array{Int64,1})</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.unsafe_logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}" href="#MeasureBase.unsafe_logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}"><code>MeasureBase.unsafe_logdensity_rel</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_logdensity_rel(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at <code>x</code>, assuming <code>x</code> is known to be in the support of both <code>m1</code> and <code>m2</code>.</p><p>See also <code>logdensity_rel</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.unsafe_logdensityof-Union{Tuple{M}, Tuple{M, Any}} where M" href="#MeasureBase.unsafe_logdensityof-Union{Tuple{M}, Tuple{M, Any}} where M"><code>MeasureBase.unsafe_logdensityof</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_logdensityof(m, x)</code></pre><p>Compute the log-density of the measure <code>m</code> at <code>x</code> relative to <code>rootmeasure(m)</code>. This is &quot;unsafe&quot; because it does not check <code>insupport(m, x)</code>.</p><p>See also <code>logdensityof</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.‚à´-Tuple{Function, AbstractMeasure}" href="#MeasureBase.‚à´-Tuple{Function, AbstractMeasure}"><code>MeasureBase.‚à´</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚à´(f, base::AbstractMeasure)</code></pre><p>Define a new measure in terms of a density <code>f</code> over some measure <code>base</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.‚à´exp-Tuple{Function, Any}" href="#MeasureBase.‚à´exp-Tuple{Function, Any}"><code>MeasureBase.‚à´exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚à´exp(f, base::AbstractMeasure)</code></pre><p>Define a new measure in terms of a log-density <code>f</code> over some measure <code>base</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.ùíπ-Tuple{AbstractMeasure, AbstractMeasure}" href="#MeasureBase.ùíπ-Tuple{AbstractMeasure, AbstractMeasure}"><code>MeasureBase.ùíπ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ùíπ(Œº::AbstractMeasure, base::AbstractMeasure)</code></pre><p>Compute the Radom-Nikodym derivative of Œº with respect to <code>base</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../affine/">¬´ Affine transformations</a><a class="docs-footer-nextpage" href="../api_measuretheory/">MeasureTheory ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Monday 16 May 2022 09:48">Monday 16 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

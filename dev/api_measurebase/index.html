<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeasureBase · MeasureTheory.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cscherrer.github.io/MeasureTheory.jl/api_measurebase/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MeasureTheory.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adding/">Adding a new measure</a></li><li><a class="tocitem" href="../affine/">AffinePushfwd transformations</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>MeasureBase</a></li><li><a class="tocitem" href="../api_measuretheory/">MeasureTheory</a></li><li><a class="tocitem" href="../api_index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>MeasureBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MeasureBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cscherrer/MeasureTheory.jl/blob/master/docs/src/api_measurebase.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MeasureBase-API"><a class="docs-heading-anchor" href="#MeasureBase-API">MeasureBase API</a><a id="MeasureBase-API-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureBase-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.Density" href="#MeasureBase.Density"><code>MeasureBase.Density</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Density{M,B}
    μ::M
    base::B
end</code></pre><p>For measures μ and ν with μ≪ν, the density of μ with respect to ν (also called the Radon-Nikodym derivative dμ/dν) is a function f defined on the support of ν with the property that for any measurable a ⊂ supp(ν), μ(a) = ∫ₐ f dν.</p><p>Because this function is often difficult to express in closed form, there are many different ways of computing it. We therefore provide a formal representation to allow comptuational flexibilty.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.DensityMeasure" href="#MeasureBase.DensityMeasure"><code>MeasureBase.DensityMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DensityMeasure{F,B} &lt;: AbstractMeasure
    density :: F
    base    :: B
end</code></pre><p>A <code>DensityMeasure</code> is a measure defined by a density with respect to some other &quot;base&quot; measure </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.Likelihood" href="#MeasureBase.Likelihood"><code>MeasureBase.Likelihood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Likelihood(k::AbstractTransitionKernel, x)</code></pre><p>&quot;Observe&quot; a value <code>x</code>, yielding a function from the parameters to ℝ.</p><p>Likelihoods are most commonly used in conjunction with an existing <em>prior</em> measure to yield a new measure, the <em>posterior</em>. In Bayes&#39;s Law, we have</p><p><span>$P(θ|x) ∝ P(θ) P(x|θ)$</span></p><p>Here <span>$P(θ)$</span> is the prior. If we consider <span>$P(x|θ)$</span> as a function on <span>$θ$</span>, then it is called a likelihood.</p><p>Since measures are most commonly manipulated using <code>density</code> and <code>logdensity</code>, it&#39;s awkward to commit a (log-)likelihood to using one or the other. To evaluate a <code>Likelihood</code>, we therefore use <code>density</code> or <code>logdensity</code>, depending on the circumstances. In the latter case, it is of course acting as a log-density.</p><p>For example,</p><pre><code class="nohighlight hljs">julia&gt; ℓ = Likelihood(Normal{(:μ,)}, 2.0)
Likelihood(Normal{(:μ,), T} where T, 2.0)

julia&gt; density_def(ℓ, (μ=2.0,))
1.0

julia&gt; logdensity_def(ℓ, (μ=2.0,))
-0.0</code></pre><p>If, as above, the measure includes the parameter information, we can optionally leave it out of the second argument in the call to <code>density</code> or <code>logdensity</code>. </p><pre><code class="nohighlight hljs">julia&gt; density_def(ℓ, 2.0)
1.0

julia&gt; logdensity_def(ℓ, 2.0)
-0.0</code></pre><p>With several parameters, things work as expected:</p><pre><code class="nohighlight hljs">julia&gt; ℓ = Likelihood(Normal{(:μ,:σ)}, 2.0)
Likelihood(Normal{(:μ, :σ), T} where T, 2.0)

julia&gt; logdensity_def(ℓ, (μ=2, σ=3))
-1.0986122886681098

julia&gt; logdensity_def(ℓ, (2,3))
-1.0986122886681098

julia&gt; logdensity_def(ℓ, [2, 3])
-1.0986122886681098</code></pre><hr/><pre><code class="nohighlight hljs">Likelihood(M&lt;:ParameterizedMeasure, constraint::NamedTuple, x)</code></pre><p>In some cases the measure might have several parameters, and we may want the (log-)likelihood with respect to some subset of them. In this case, we can use the three-argument form, where the second argument is a constraint. For example,</p><pre><code class="nohighlight hljs">julia&gt; ℓ = Likelihood(Normal{(:μ,:σ)}, (σ=3.0,), 2.0)
Likelihood(Normal{(:μ, :σ), T} where T, (σ = 3.0,), 2.0)</code></pre><p>Similarly to the above, we have</p><pre><code class="nohighlight hljs">julia&gt; density_def(ℓ, (μ=2.0,))
0.3333333333333333

julia&gt; logdensity_def(ℓ, (μ=2.0,))
-1.0986122886681098

julia&gt; density_def(ℓ, 2.0)
0.3333333333333333

julia&gt; logdensity_def(ℓ, 2.0)
-1.0986122886681098</code></pre><hr/><p>Finally, let&#39;s return to the expression for Bayes&#39;s Law, </p><p><span>$P(θ|x) ∝ P(θ) P(x|θ)$</span></p><p>The product on the right side is computed pointwise. To work with this in MeasureBase, we have a &quot;pointwise product&quot; <code>⊙</code>, which takes a measure and a likelihood, and returns a new measure, that is, the unnormalized posterior that has density <span>$P(θ) P(x|θ)$</span> with respect to the base measure of the prior.</p><p>For example, say we have</p><pre><code class="nohighlight hljs">μ ~ Normal()
x ~ Normal(μ,σ)
σ = 1</code></pre><p>and we observe <code>x=3</code>. We can compute the posterior measure on <code>μ</code> as</p><pre><code class="nohighlight hljs">julia&gt; post = Normal() ⊙ Likelihood(Normal{(:μ, :σ)}, (σ=1,), 3)
Normal() ⊙ Likelihood(Normal{(:μ, :σ), T} where T, (σ = 1,), 3)

julia&gt; logdensity_def(post, 2)
-2.5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.NoArgCheck" href="#MeasureBase.NoArgCheck"><code>MeasureBase.NoArgCheck</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.NoArgCheck{MU,T}</code></pre><p>Indicates that there is no way to check of a values of type <code>T</code> are variate of measures of type <code>MU</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.NoDOF" href="#MeasureBase.NoDOF"><code>MeasureBase.NoDOF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.NoDOF{MU}</code></pre><p>Indicates that there is no way to compute degrees of freedom of a measure of type <code>MU</code> with the given information, e.g. because the DOF are not a global property of the measure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.NoTransformOrigin" href="#MeasureBase.NoTransformOrigin"><code>MeasureBase.NoTransformOrigin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MeasureBase.NoTransformOrigin{NU}</code></pre><p>Indicates that no (default) pullback measure is available for measures of type <code>NU</code>.</p><p>See <a href="#MeasureBase.transport_origin"><code>MeasureBase.transport_origin</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.NoTransport" href="#MeasureBase.NoTransport"><code>MeasureBase.NoTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MeasureBase.NoTransport{NU,MU} end</code></pre><p>Indicates that no transformation from a measure of type <code>MU</code> to a measure of type <code>NU</code> could be found.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.NoVolCorr" href="#MeasureBase.NoVolCorr"><code>MeasureBase.NoVolCorr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoVolCorr()</code></pre><p>Indicate that density calculations should ignore the volume element of variate transformations. Should only be used in special cases in which the volume element has already been taken into account in a different way.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.PrimitiveMeasure" href="#MeasureBase.PrimitiveMeasure"><code>MeasureBase.PrimitiveMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveMeasure &lt;: AbstractMeasure end</code></pre><p>In the MeasureTheory ecosystem, a <em>primitive</em> measure is a measure for which the definition and construction do not depend on any other measure. Primitive measures satisfy the following laws:</p><pre><code class="nohighlight hljs">basemeasure(μ::PrimitiveMeasure) = μ

logdensity_def(μ::PrimitiveMeasure, x) = 0.0

logdensity_def(μ::M, ν::M, x) where {M&lt;:PrimitiveMeasure} = 0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.PushforwardMeasure" href="#MeasureBase.PushforwardMeasure"><code>MeasureBase.PushforwardMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PushforwardMeasure{FF,IF,MU,VC&lt;:TransformVolCorr} &lt;: AbstractPushforward
    f :: FF
    inv_f :: IF
    origin :: MU
    volcorr :: VC
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.SuperpositionMeasure" href="#MeasureBase.SuperpositionMeasure"><code>MeasureBase.SuperpositionMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SuperpositionMeasure{NT} &lt;: AbstractMeasure
    components :: NT
end</code></pre><p>Superposition of measures is analogous to mixture distributions, but (because measures need not be normalized) requires no scaling. The superposition of two measures μ and ν can be more concisely written as μ + ν. Superposition measures satisfy</p><pre><code class="nohighlight hljs">basemeasure(μ + ν) == basemeasure(μ) + basemeasure(ν)</code></pre><p class="math-container">\[    \begin{aligned}\frac{\mathrm{d}(\mu+\nu)}{\mathrm{d}(\alpha+\beta)} &amp; =\frac{f\,\mathrm{d}\alpha+g\,\mathrm{d}\beta}{\mathrm{d}\alpha+\mathrm{d}\beta}\\
     &amp; =\frac{f\,\mathrm{d}\alpha}{\mathrm{d}\alpha+\mathrm{d}\beta}+\frac{g\,\mathrm{d}\beta}{\mathrm{d}\alpha+\mathrm{d}\beta}\\
     &amp; =\frac{f}{1+\frac{\mathrm{d}\beta}{\mathrm{d}\alpha}}+\frac{g}{\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}+1}\\
     &amp; =\frac{f}{1+\left(\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}\right)^{-1}}+\frac{g}{\frac{\mathrm{d}\alpha}{\mathrm{d}\beta}+1}\ .
    \end{aligned}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.TransformVolCorr" href="#MeasureBase.TransformVolCorr"><code>MeasureBase.TransformVolCorr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type TransformVolCorr</code></pre><p>Provides control over density correction by transform volume element. Either <a href="#MeasureBase.NoVolCorr"><code>NoVolCorr()</code></a> or <a href="#MeasureBase.WithVolCorr"><code>WithVolCorr()</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.TransportFunction" href="#MeasureBase.TransportFunction"><code>MeasureBase.TransportFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TransportFunction &lt;: Function</code></pre><p>Transforms a variate from one measure to a variate of another.</p><p>In general <code>TransportFunction</code> should not be called directly, call <a href="#MeasureBase.transport_to"><code>transport_to</code></a> instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.WithVolCorr" href="#MeasureBase.WithVolCorr"><code>MeasureBase.WithVolCorr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WithVolCorr()</code></pre><p>Indicate that density calculations should take the volume element of variate transformations into account (typically via the log-abs-det-Jacobian of the transform).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{AbstractMeasure, Any}" href="#Base.:|-Tuple{AbstractMeasure, Any}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(m::AbstractMeasure) | constraint</code></pre><p>Return a new measure by constraining <code>m</code> to satisfy <code>constraint</code>.</p><p>Note that the form of <code>constraint</code> will vary depending on the structure of a given measure. For example, a measure over <code>NamedTuple</code>s may allow <code>NamedTuple</code> constraints, while another may require <code>constraint</code> to be a predicate or a function returning a real number (in which case the constraint could be considered as the zero-set of that function). </p><p>At the time of this writing, invariants required of this function are not yet settled. Specifically, there&#39;s the question of normalization. It&#39;s common for conditional distributions to be normalized, but this can often not be expressed in closed form, and can be very expensive to compute. For more general measures, the notion of normalization may not even make sense.</p><p>Because of this, this interface is not yet stable, and users should expect upcoming changes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DensityInterface.logdensityof-Tuple{AbstractMeasure, Any}" href="#DensityInterface.logdensityof-Tuple{AbstractMeasure, Any}"><code>DensityInterface.logdensityof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logdensityof(m::AbstractMeasure, x)</code></pre><p>Compute the log-density of the measure <code>m</code> at <code>x</code>. Density is always relative, but <code>DensityInterface.jl</code> does not account for this. For compatibility with this, <code>logdensityof</code> for a measure is always implicitly relative to <a href="#MeasureBase.rootmeasure-Tuple{Any}"><code>rootmeasure(x)</code></a>. </p><p><code>logdensityof</code> works by first computing <code>insupport(m, x)</code>. If this is true, then <code>unsafe_logdensityof</code> is called. If <code>insupport(m, x)</code> is known to be <code>true</code>, it can be a little faster to directly call <code>unsafe_logdensityof(m, x)</code>. </p><p>To compute log-density relative to <code>basemeasure(m)</code> or <em>define</em> a log-density (relative to <code>basemeasure(m)</code> or another measure given explicitly), see <code>logdensity_def</code>. </p><p>To compute a log-density relative to a specific base-measure, see <code>logdensity_rel</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.:↣-Tuple{Any, Any}" href="#MeasureBase.:↣-Tuple{Any, Any}"><code>MeasureBase.:↣</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If </p><ul><li>μ is an <code>AbstractMeasure</code> or satisfies the Measure interface, and</li><li>k is a function taking values from the support of μ and returning a measure</li></ul><p>Then <code>μ ↣ k</code> is a measure, called a <em>monadic bind</em>. In a probabilistic programming language like Soss.jl, this could be expressed as</p><p>Note that bind is usually written <code>&gt;&gt;=</code>, but this symbol is unavailable in Julia.</p><pre><code class="nohighlight hljs">bind = @model μ,k begin 
    x ~ μ
    y ~ k(x)
    return y
end</code></pre><p>See also <code>bind</code> and <code>Bind</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.:⊗-Tuple{Vararg{AbstractMeasure}}" href="#MeasureBase.:⊗-Tuple{Vararg{AbstractMeasure}}"><code>MeasureBase.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊗(μs::AbstractMeasure...)</code></pre><p><code>⊗</code> is a binary operator for building product measures. This satisfies the law</p><pre><code class="nohighlight hljs">    basemeasure(μ ⊗ ν) == basemeasure(μ) ⊗ basemeasure(ν)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.basekernel" href="#MeasureBase.basekernel"><code>MeasureBase.basekernel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>For any <code>k::TransitionKernel</code>, <code>basekernel</code> is expected to satisfy</p><pre><code class="nohighlight hljs">basekernel(k)(p) == (basemeasure ∘ k)(p)</code></pre><p>The main purpose of <code>basekernel</code> is to make it efficient to compute</p><pre><code class="nohighlight hljs">basemeasure(d::ProductMeasure) == productmeasure(basekernel(d.f), d.xs)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.basemeasure_sequence-Tuple{M} where M" href="#MeasureBase.basemeasure_sequence-Tuple{M} where M"><code>MeasureBase.basemeasure_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemeasure_sequence(m)</code></pre><p>Construct the longest <code>Tuple</code> starting with <code>m</code> having each term as the base measure of the previous term, and with no repeated entries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.check_dof" href="#MeasureBase.check_dof"><code>MeasureBase.check_dof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.check_dof(ν, μ)::Nothing</code></pre><p>Check if <code>ν</code> and <code>μ</code> have the same effective number of degrees of freedom according to <a href="#MeasureBase.getdof"><code>MeasureBase.getdof</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.checked_arg" href="#MeasureBase.checked_arg"><code>MeasureBase.checked_arg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.checked_arg(μ::MU, x::T)::T</code></pre><p>Return <code>x</code> if <code>x</code> is a valid variate of <code>μ</code>, throw an <code>ArgumentError</code> if not, return <code>NoArgCheck{MU,T}()</code> if not check can be performed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.commonbase-Union{Tuple{T}, Tuple{Any, Any, Type{T}}} where T" href="#MeasureBase.commonbase-Union{Tuple{T}, Tuple{Any, Any, Type{T}}} where T"><code>MeasureBase.commonbase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commonbase(μ, ν, T) -&gt; Tuple{StaticInt{i}, StaticInt{j}}</code></pre><p>Find minimal (with respect to their sum) <code>i</code> and <code>j</code> such that there is a method</p><pre><code class="nohighlight hljs">logdensity_def(basemeasure_sequence(μ)[i], basemeasure_sequence(ν)[j], ::T)</code></pre><p>This is used in <code>logdensity_rel</code> to help make that function efficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.from_origin" href="#MeasureBase.from_origin"><code>MeasureBase.from_origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.from_origin(ν, x)</code></pre><p>Push <code>x</code> from <code>MeasureBase.transport_origin(μ)</code> forward to <code>ν</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.getdof" href="#MeasureBase.getdof"><code>MeasureBase.getdof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdof(μ)</code></pre><p>Returns the effective number of degrees of freedom of variates of measure <code>μ</code>.</p><p>The effective NDOF my differ from the length of the variates. For example, the effective NDOF for a Dirichlet distribution with variates of length <code>n</code> is <code>n - 1</code>.</p><p>Also see <a href="#MeasureBase.check_dof"><code>check_dof</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.insupport" href="#MeasureBase.insupport"><code>MeasureBase.insupport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inssupport(m, x)
insupport(m)</code></pre><p><code>insupport(m,x)</code> computes whether <code>x</code> is in the support of <code>m</code>.</p><p><code>insupport(m)</code> returns a function, and satisfies</p><p>insupport(m)(x) == insupport(m, x)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.jointof-Tuple{Any}" href="#MeasureBase.jointof-Tuple{Any}"><code>MeasureBase.jointof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jointof(m)</code></pre><p>Some Probabilistic Programming Languages (PPLs) like Tilde.jl make a distinction between a <em>latent space</em>, often a namespace represented as a named tuple, and the space containing the return value, which we refer to as the <em>maifest space</em>. The distinction is that computations are done in terms of the latent space, while the resulting value is in the manifest space.</p><p>To simplify many manipulations involving these concepts, we introduce the concept of a <em>joint space</em>. For example, suppose <code>m()</code> is a measure with latent space <code>NamedTuple{(:a, :b)}</code> that returns <code>a - b</code>, so the latent value <code>(a = 3, b = 4)</code> is mapped to the manifest value <code>0.75</code>. Then the corresponding value in the joint space is the pair <code>(a = 3, b = 4) =&gt; 0.75</code>.</p><p>One of the many goals of probabilistic programming is to blur the line between &quot;built in&quot; measures like <code>Normal()</code> and those defined in terms of a model from a PPL. To accommodate this, we extend these concepts to general measures. </p><p>For many measures, it&#39;s convenient to work directly in the manifest space, and there&#39;s no need for such separation. However, it&#39;s important to be able to manipulate measures programmatically, with minimal special cases. Because of this, we introduce fall-back methods</p><pre><code class="nohighlight hljs">latentof(m) = m
manifestof(m) = m</code></pre><p>The default implementation of <code>jointof</code> is then a push-forward through the function <code>x -&gt; (x =&gt; x)</code>. For example,</p><pre><code class="nohighlight hljs">julia&gt; rand(MeasureBase.jointof(StdUniform()))
0.346439=&gt;0.346439</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.kernel" href="#MeasureBase.kernel"><code>MeasureBase.kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A <em>kernel</em> is a function that returns a measure.</p><pre><code class="nohighlight hljs">k1 = kernel() do x
    Normal(x, x^2)
end

k2 = kernel(Normal) do x
    (μ = x, σ = x^2)
end

k3 = kernel(Normal; μ = identity, σ = abs2)

k4 = kernel(Normal; μ = first, σ = last) do x
    (x, x^2)
end

x = randn(); k1(x) == k2(x) == k3(x) == k4(x)</code></pre><p>This function is not exported, because &quot;kernel&quot; can have so many other meanings. See for example https://github.com/JuliaGaussianProcesses/KernelFunctions.jl for another common use of this term.</p><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Markov_kernel</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.latentof-Tuple{Any}" href="#MeasureBase.latentof-Tuple{Any}"><code>MeasureBase.latentof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latentof(m)</code></pre><p>Some Probabilistic Programming Languages (PPLs) like Tilde.jl make a distinction between a <em>latent space</em>, often a namespace represented as a named tuple, and the space containing the return value, which we refer to as the <em>maifest space</em>. The distinction is that computations are done in terms of the latent space, while the resulting value is in the manifest space.</p><p>To simplify many manipulations involving these concepts, we introduce the concept of a <em>joint space</em>. For example, suppose <code>m()</code> is a measure with latent space <code>NamedTuple{(:a, :b)}</code> that returns <code>a - b</code>, so the latent value <code>(a = 3, b = 4)</code> is mapped to the manifest value <code>0.75</code>. Then the corresponding value in the joint space is the pair <code>(a = 3, b = 4) =&gt; 0.75</code>.</p><p>One of the many goals of probabilistic programming is to blur the line between &quot;built in&quot; measures like <code>Normal()</code> and those defined in terms of a model from a PPL. To accommodate this, we extend these concepts to general measures. </p><p>For many measures, it&#39;s convenient to work directly in the manifest space, and there&#39;s no need for such separation. However, it&#39;s important to be able to manipulate measures programmatically, with minimal special cases. Because of this, we introduce fall-back methods</p><pre><code class="nohighlight hljs">latentof(m) = m
manifestof(m) = m</code></pre><p>The default implementation of <code>jointof</code> is then a push-forward through the function <code>x -&gt; (x =&gt; x)</code>. For example,</p><pre><code class="nohighlight hljs">julia&gt; rand(MeasureBase.jointof(StdUniform()))
0.346439=&gt;0.346439</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.likelihood_ratio-Tuple{Likelihood, Any, Any}" href="#MeasureBase.likelihood_ratio-Tuple{Likelihood, Any, Any}"><code>MeasureBase.likelihood_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">likelihood_ratio(ℓ::Likelihood, p, q)</code></pre><p>Compute the log of the likelihood ratio, in order to compare two choices for parameters. This is equal to</p><pre><code class="nohighlight hljs">density_rel(ℓ.k(p), ℓ.k(q), ℓ.x)</code></pre><p>but is computed using LogarithmicNumbers.jl to avoid underflow and overflow. Since <code>density_rel</code> can leave common base measure unevaluated, this can be more efficient than</p><pre><code class="nohighlight hljs">logdensityof(ℓ.k(p), ℓ.x) - logdensityof(ℓ.k(q), ℓ.x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.likelihoodof" href="#MeasureBase.likelihoodof"><code>MeasureBase.likelihoodof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">likelihoodof(k::AbstractTransitionKernel, x; constraints...)
likelihoodof(k::AbstractTransitionKernel, x, constraints::NamedTuple)</code></pre><p>A likelihood is <em>not</em> a measure. Rather, a likelihood acts on a measure, through the &quot;pointwise product&quot; <code>⊙</code>, yielding another measure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.log_likelihood_ratio-Tuple{Likelihood, Any, Any}" href="#MeasureBase.log_likelihood_ratio-Tuple{Likelihood, Any, Any}"><code>MeasureBase.log_likelihood_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_likelihood_ratio(ℓ::Likelihood, p, q)</code></pre><p>Compute the log of the likelihood ratio, in order to compare two choices for parameters. This is computed as</p><pre><code class="nohighlight hljs">logdensity_rel(ℓ.k(p), ℓ.k(q), ℓ.x)</code></pre><p>Since <code>logdensity_rel</code> can leave common base measure unevaluated, this can be more efficient than</p><pre><code class="nohighlight hljs">logdensityof(ℓ.k(p), ℓ.x) - logdensityof(ℓ.k(q), ℓ.x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.logdensity_def" href="#MeasureBase.logdensity_def"><code>MeasureBase.logdensity_def</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>logdensity_def</code> is the standard way to define a log-density for a new measure. Note that this definition does not include checking for membership in the support; this is instead checked using <code>insupport</code>. <code>logdensity_def</code> is a low-level function, and should typically not be called directly. See <code>logdensityof</code> for more information and other alternatives.</p><hr/><pre><code class="nohighlight hljs">logdensity_def(m, x)</code></pre><p>Compute the log-density of the measure m at the point <code>x</code>, relative to <code>basemeasure(m)</code>, and assuming <code>insupport(m, x)</code>.</p><hr/><pre><code class="nohighlight hljs">logdensity_def(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at the point <code>x</code>, assuming <code>insupport(m1, x)</code> and <code>insupport(m2, x)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}" href="#MeasureBase.logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}"><code>MeasureBase.logdensity_rel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logdensity_rel(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at <code>x</code>. This function checks whether <code>x</code> is in the support of <code>m1</code> or <code>m2</code> (or both, or neither). If <code>x</code> is known to be in the support of both, it can be more efficient to call <code>unsafe_logdensity_rel</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.manifestof-Tuple{Any}" href="#MeasureBase.manifestof-Tuple{Any}"><code>MeasureBase.manifestof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifestof(m)</code></pre><p>Some Probabilistic Programming Languages (PPLs) like Tilde.jl make a distinction between a <em>latent space</em>, often a namespace represented as a named tuple, and the space containing the return value, which we refer to as the <em>maifest space</em>. The distinction is that computations are done in terms of the latent space, while the resulting value is in the manifest space.</p><p>To simplify many manipulations involving these concepts, we introduce the concept of a <em>joint space</em>. For example, suppose <code>m()</code> is a measure with latent space <code>NamedTuple{(:a, :b)}</code> that returns <code>a - b</code>, so the latent value <code>(a = 3, b = 4)</code> is mapped to the manifest value <code>0.75</code>. Then the corresponding value in the joint space is the pair <code>(a = 3, b = 4) =&gt; 0.75</code>.</p><p>One of the many goals of probabilistic programming is to blur the line between &quot;built in&quot; measures like <code>Normal()</code> and those defined in terms of a model from a PPL. To accommodate this, we extend these concepts to general measures. </p><p>For many measures, it&#39;s convenient to work directly in the manifest space, and there&#39;s no need for such separation. However, it&#39;s important to be able to manipulate measures programmatically, with minimal special cases. Because of this, we introduce fall-back methods</p><pre><code class="nohighlight hljs">latentof(m) = m
manifestof(m) = m</code></pre><p>The default implementation of <code>jointof</code> is then a push-forward through the function <code>x -&gt; (x =&gt; x)</code>. For example,</p><pre><code class="nohighlight hljs">julia&gt; rand(MeasureBase.jointof(StdUniform()))
0.346439=&gt;0.346439</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.paramnames" href="#MeasureBase.paramnames"><code>MeasureBase.paramnames</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>paramnames(μ)</code> returns the names of the parameters of <code>μ</code>. This is equivalent to </p><pre><code class="nohighlight hljs">paramnames(μ) == (keys ∘ params)(μ)</code></pre><p>but depends only on the type. In particular, the default implementation is</p><pre><code class="nohighlight hljs">paramnames(μ::M) where {M} = paramnames(M)</code></pre><p>New <code>ParameterizedMeasure</code>s will automatically have a <code>paramnames</code> method. For other measures, this method is optional, but can be added by defining</p><pre><code class="nohighlight hljs">paramnames(::Type{M}) where {M} = ...</code></pre><p>See also <code>params</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.params" href="#MeasureBase.params"><code>MeasureBase.params</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>params(μ)</code> returns the parameters of a measure <code>μ</code>, as a <code>NamedTuple</code>. The default method is</p><pre><code class="nohighlight hljs">params(μ) = NamedTuple()</code></pre><p>See also <code>paramnames</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.proxy" href="#MeasureBase.proxy"><code>MeasureBase.proxy</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function proxy end</p><p>It&#39;s often useful to delegate methods like <code>logdensity</code> and <code>basemeasure</code> to those of a different measure. For example, a <code>Normal{(:μ,:σ)}</code> is equivalent to an affine transformation of a <code>Normal{()}</code>.</p><p>We <em>could</em> just have calls like <code>Normal(μ=2,σ=4)</code> directly construct a transformed measure, but this would make dispatch awkward.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.pushfwd" href="#MeasureBase.pushfwd"><code>MeasureBase.pushfwd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pushfwd(f, μ, volcorr = WithVolCorr())</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Pushforward_measure">pushforward measure</a> from <code>μ</code> the <a href="https://en.wikipedia.org/wiki/Measurable_function">measurable function</a> <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.rebase-Tuple{Any, Any}" href="#MeasureBase.rebase-Tuple{Any, Any}"><code>MeasureBase.rebase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebase(μ, ν)</code></pre><p>Express <code>μ</code> in terms of a density over <code>ν</code>. Satisfies</p><pre><code class="nohighlight hljs">basemeasure(rebase(μ, ν)) == ν
density(rebase(μ, ν)) == 𝒹(μ,ν)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.require_insupport" href="#MeasureBase.require_insupport"><code>MeasureBase.require_insupport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.require_insupport(μ, x)::Nothing</code></pre><p>Checks if <code>x</code> is in the support of distribution/measure <code>μ</code>, throws an <code>ArgumentError</code> if not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.rootmeasure-Tuple{Any}" href="#MeasureBase.rootmeasure-Tuple{Any}"><code>MeasureBase.rootmeasure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootmeasure(μ::AbstractMeasure)</code></pre><p>It&#39;s sometimes important to be able to find the fix point of a measure under <code>basemeasure</code>. That is, to start with some measure and apply <code>basemeasure</code> repeatedly until there&#39;s no change. That&#39;s what this does.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.schema" href="#MeasureBase.schema"><code>MeasureBase.schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schema(::Type)</code></pre><p><code>schema</code> turns a type into a value that&#39;s easier to work with. Example:     julia&gt; nt = (a=(b=[1,2],c=(d=[3,4],e=[5,6])),f=[7,8]);     julia&gt; NT = typeof(nt)     NamedTuple{(:a, :f),Tuple{NamedTuple{(:b, :c),Tuple{Array{Int64,1},NamedTuple{(:d, :e),Tuple{Array{Int64,1},Array{Int64,1}}}}},Array{Int64,1}}}     julia&gt; schema(NT)     (a = (b = Array{Int64,1}, c = (d = Array{Int64,1}, e = Array{Int64,1})), f = Array{Int64,1})</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.to_origin" href="#MeasureBase.to_origin"><code>MeasureBase.to_origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.to_origin(ν, y)</code></pre><p>Pull <code>y</code> from <code>ν</code> back to <code>MeasureBase.transport_origin(ν)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.transport_def" href="#MeasureBase.transport_def"><code>MeasureBase.transport_def</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transport_def(ν, μ, x)</code></pre><p>Transforms a value <code>x</code> distributed according to <code>μ</code> to a value <code>y</code> distributed according to <code>ν</code>.</p><p>If no specialized <code>transport_def(::MU, ::NU, ...)</code> is available then the default implementation of<code>transport_def(ν, μ, x)</code> uses the following strategy:</p><ul><li><p>Evaluate <a href="#MeasureBase.transport_origin"><code>transport_origin</code></a> for μ and ν. Transform between each and it&#39;s origin, if available, and use the origin(s) as intermediate measures for another transformation.</p></li><li><p>If all else fails, try to transform from μ to a standard multivariate uniform measure and then to ν.</p></li></ul><p>See <a href="#MeasureBase.transport_to"><code>transport_to</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.transport_origin" href="#MeasureBase.transport_origin"><code>MeasureBase.transport_origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MeasureBase.transport_origin(ν)</code></pre><p>Default measure to pullback to resp. pushforward from when transforming between <code>ν</code> and another measure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.transport_to" href="#MeasureBase.transport_to"><code>MeasureBase.transport_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f = transport_to(ν, μ)</code></pre><p>Generates a <a href="https://en.wikipedia.org/wiki/Measurable_function">measurable function</a> <code>f</code> that transforms a value <code>x</code> distributed according to measure <code>μ</code> to a value <code>y = f(x)</code> distributed according to a measure <code>ν</code>.</p><p>The <a href="https://en.wikipedia.org/wiki/Pushforward_measure">pushforward measure</a> from <code>μ</code> under <code>f</code> is is equivalent to <code>ν</code>.</p><p>If terms of random values this implies that <code>f(rand(μ))</code> is equivalent to <code>rand(ν)</code> (if <code>rand(μ)</code> and <code>rand(ν)</code> are supported).</p><p>The resulting function <code>f</code> should support <code>ChangesOfVariables.with_logabsdet_jacobian(f, x)</code> if mathematically well-defined, so that densities of <code>ν</code> can be derived from densities of <code>μ</code> via <code>f</code> (using appropriate base measures).</p><p>Returns NoTransformOrigin{typeof(ν),typeof(μ)} if no transformation from <code>μ</code> to <code>ν</code> can be found.</p><p>To add transformation rules for a measure type <code>MyMeasure</code>, specialize</p><ul><li><code>MeasureBase.transport_def(ν::SomeStdMeasure, μ::CustomMeasure, x) = ...</code></li><li><code>MeasureBase.transport_def(ν::MyMeasure, μ::SomeStdMeasure, x) = ...</code></li></ul><p>and/or</p><ul><li><code>MeasureBase.transport_origin(ν::MyMeasure) = SomeMeasure(...)</code></li><li><code>MeasureBase.from_origin(μ::MyMeasure, x) = y</code></li><li><code>MeasureBase.to_origin(μ::MyMeasure, y) = x</code></li></ul><p>and ensure <code>MeasureBase.getdof(μ::MyMeasure)</code> is defined correctly.</p><p>A standard measure type like <code>StdUniform</code>, <code>StdExponential</code> or <code>StdLogistic</code> may also be used as the source or target of the transform:</p><pre><code class="language-julia hljs">f_to_uniform(StdUniform, μ)
f_to_uniform(ν, StdUniform)</code></pre><p>Depending on <a href="#MeasureBase.getdof"><code>getdof(μ)</code></a> (resp. <code>ν</code>), an instance of the standard distribution itself or a power of it (e.g. <code>StdUniform()</code> or <code>StdUniform()^dof</code>) will be chosen as the transformation partner.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.unsafe_logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}" href="#MeasureBase.unsafe_logdensity_rel-Union{Tuple{X}, Tuple{N}, Tuple{M}, Tuple{M, N, X}} where {M, N, X}"><code>MeasureBase.unsafe_logdensity_rel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_logdensity_rel(m1, m2, x)</code></pre><p>Compute the log-density of <code>m1</code> relative to <code>m2</code> at <code>x</code>, assuming <code>x</code> is known to be in the support of both <code>m1</code> and <code>m2</code>.</p><p>See also <code>logdensity_rel</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.unsafe_logdensityof-Union{Tuple{M}, Tuple{M, Any}} where M" href="#MeasureBase.unsafe_logdensityof-Union{Tuple{M}, Tuple{M, Any}} where M"><code>MeasureBase.unsafe_logdensityof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_logdensityof(m, x)</code></pre><p>Compute the log-density of the measure <code>m</code> at <code>x</code> relative to <code>rootmeasure(m)</code>. This is &quot;unsafe&quot; because it does not check <code>insupport(m, x)</code>.</p><p>See also <code>logdensityof</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.∫-Tuple{Function, AbstractMeasure}" href="#MeasureBase.∫-Tuple{Function, AbstractMeasure}"><code>MeasureBase.∫</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∫(f, base::AbstractMeasure)</code></pre><p>Define a new measure in terms of a density <code>f</code> over some measure <code>base</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.∫exp-Tuple{Function, Any}" href="#MeasureBase.∫exp-Tuple{Function, Any}"><code>MeasureBase.∫exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∫exp(f, base::AbstractMeasure)</code></pre><p>Define a new measure in terms of a log-density <code>f</code> over some measure <code>base</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MeasureBase.𝒹-Tuple{AbstractMeasure, AbstractMeasure}" href="#MeasureBase.𝒹-Tuple{AbstractMeasure, AbstractMeasure}"><code>MeasureBase.𝒹</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">𝒹(μ::AbstractMeasure, base::AbstractMeasure)</code></pre><p>Compute the Radom-Nikodym derivative of μ with respect to <code>base</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../affine/">« AffinePushfwd transformations</a><a class="docs-footer-nextpage" href="../api_measuretheory/">MeasureTheory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 9 September 2022 17:51">Friday 9 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

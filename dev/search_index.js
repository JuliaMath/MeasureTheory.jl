var documenterSearchIndex = {"docs":
[{"location":"intro/","page":"Introduction","title":"Introduction","text":"There are lots of packages for working with probability distributions. But very often, we need to work with \"distributions\" that really aren't. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For example, the correspondence between regularization and Bayesian prior distributions leads naturally to the idea of extending probabilistic programming systems to cover both. But it's easy to come up with a loss function for which the integral of the corresponding \"prior\" is infinite! The result is not really a distirbution. It is, however, still a measure.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Even restricted to Bayesian methods, users might sometimes want to use an improper prior. By definition, these cannot be integrated over their domain. But an improper prior is still a measure.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In Markov chain Monte Carlo (MCMC), we often work with distributions for which we can only caluculate  the log-density up to an additive constant. Considering this instead as a measure can be helpful. Even better, consdering intermediate computations along the way as computations on measures saves us from computing normalization terms where the end result will discard this anyway.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To be clear, that's not to say that we always discard normalizations. Rather, they're considered as belonging to the measure itself, rather than being included in each sub-computation. If measures you work with happen to also be probability distributions, you'll always be able to recover those results.","category":"page"},{"location":"adding/#Adding-a-New-Measure","page":"Adding a New Measure","title":"Adding a New Measure","text":"","category":"section"},{"location":"adding/#Parameterized-Measures","page":"Adding a New Measure","title":"Parameterized Measures","text":"","category":"section"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"This is by far the most common kind of measure, and is especially useful as a way to describe families of probability distributions.","category":"page"},{"location":"adding/#Declaring-a-Parameterized-Measure","page":"Adding a New Measure","title":"Declaring a Parameterized Measure","text":"","category":"section"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"To start, declare a @parameterized. For example, Normal is declared as","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"@parameterized Normal(Œº,œÉ) ‚â™ (1/sqrt2œÄ) * Lebesgue(‚Ñù)","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"[‚Ñù is typed as \\bbR <TAB>]","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"A ParameterizedMeasure can have multiple parameterizations, which as dispatched according to the names of the parameters. The (Œº,œÉ) here specifies names to assign if none are given. So for example,","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"julia> Normal(-3.0, 2.1)\nNormal(Œº = -3.0, œÉ = 2.1)","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"The right side, (1/sqrt2œÄ) * Lebesgue(‚Ñù), gives the base measure. Lebesgue in this case is the technical name for the measure associating an interval of real numbers to its length. The (1/sqrt2œÄ) comes from the normalization constant in the probability density function,","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"f_textNormal(xŒºœÉ) = frac1œÉ sqrt2 pi e^-frac12left(fracx-musigmaright)^2  ","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Making this part of the base measure allows us to avoid including it in every computation.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"The ‚â™ (typed as \\ll <TAB>) can be read \"is dominated by\". This just means that any set for which the base measure is zero must also have zero measure in what we're defining.","category":"page"},{"location":"adding/#Defining-a-Log-Density","page":"Adding a New Measure","title":"Defining a Log Density","text":"","category":"section"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Most computations involve log-densities rather than densities themselves, so these are our first priority. density(d,x) will default to exp(logdensity(d,x)), but you can add a separate method if it's more efficient.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"The definition is simple:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"logdensity(d::Normal{()} , x) = - x^2 / 2 ","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"There are a few things here worth noting.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"First, we dispatch by the names of d (here there are none), and the type of x is not specified.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Also, there's nothing here about Œº and œÉ. These location-scale parameters behave exactly the same across lots of distributions, so we have a macro to add them:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"@ŒºœÉ_methods Normal()","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Let's look at another example, the Beta distribution. Here the base measure is Lebesgue(ùïÄ) (support is the unit interval). The log-density is","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"function logdensity(d::Beta{(:Œ±, :Œ≤)}, x)\n    return (d.Œ± - 1) * log(x) + (d.Œ≤ - 1) * log(1 - x) - logbeta(d.Œ±, d.Œ≤)\nend","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Note that when possible, we avoid extra control flow for checking that x is in the support. In applications, log-densities are often evaluated only on the support by design. Such checks should be implemented at a higher level whenever there is any doubt.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Finally, note that in both of these examples, the log-density has a relatively direct algebraic form. It's imnportant to have this whenever possible to allow for symbolic manipulation (using libraries like SymolicUtils.jl) and efficient automatic differentiation.","category":"page"},{"location":"adding/#Random-Sampling","page":"Adding a New Measure","title":"Random Sampling","text":"","category":"section"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"For univariate distributions, you should define a Base.rand method that uses three arguments:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"A Random.AbstractRNG to use for randomization,\nA type to be returned, and\nThe measure to sample from.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"For our Normal example, this is","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Base.rand(rng::Random.AbstractRNG, T::Type, d::Normal{()}) = randn(rng, T)","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Again, for location-scale families, other methods are derived automatically. ","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"For multivariate distributions (or anything that requires heap allocation), you should instead define a Random.rand! method. This also takes three arguments, different from rand:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"The Random.AbstractRNG,\nThe measure to sample from, and\nWhere to store the result.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"For example, here's the implementation for ProductMeasure:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"@propagate_inbounds function Random.rand!(rng::AbstractRNG, d::ProductMeasure, x::AbstractArray)\n    @boundscheck size(d.data) == size(x) || throw(BoundsError)\n\n    @inbounds for j in eachindex(x)\n        x[j] = rand(rng, eltype(x), d.data[j])\n    end\n    x\nend","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Note that in this example, d.data[j] might itself require allocation. This implementation is likely to change in the future to make it easier to define nested structures without any need for ongoing allocation.","category":"page"},{"location":"adding/#Primitive-Measures","page":"Adding a New Measure","title":"Primitive Measures","text":"","category":"section"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Most measures are defined in terms of a logdensity with respect to some other measure, its basemeasure. But how is that measure defined? It can't be \"densities all the way down\"; at some point, the chain has to stop.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"A primitive measure is just a measure that has itself as its own base measure. Note that this also means its log-density is always zero.","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"Here's the implementation of Lebesgue:","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"struct Lebesgue{X} <: AbstractMeasure end\n\nLebesgue(X) = Lebesgue{X}()\n\nbasemeasure(Œº::Lebesgue) = Œº\n\nisprimitive(::Lebesgue) = true\n\nsampletype(::Lebesgue{‚Ñù}) = Float64\nsampletype(::Lebesgue{‚Ñù‚Çä}) = Float64\nsampletype(::Lebesgue{ùïÄ}) = Float64\n\nlogdensity(::Lebesgue, x) = zero(float(x))","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"We haven't yet talked about sampletype. When you call rand without specifying a type, there needs to be a default. That default is the sampletype. This only needs to be defined for primitive measures, because others will fall back on ","category":"page"},{"location":"adding/","page":"Adding a New Measure","title":"Adding a New Measure","text":"sampletype(Œº::AbstractMeasure) = sampletype(basemeasure(Œº))","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MeasureTheory","category":"page"},{"location":"#MeasureTheory","page":"Home","title":"MeasureTheory","text":"","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MeasureTheory]","category":"page"},{"location":"#MeasureTheory.CorrCholesky","page":"Home","title":"MeasureTheory.CorrCholesky","text":"CorrCholesky(n)\n\nCholesky factor of a correlation matrix of size n. Transforms n(n-1)2 real numbers to an nn lower-triangular matrix L, such that L*L' is a correlation matrix (positive definite, with unit diagonal).\n\nNotes\n\nIf\n\nz is a vector of n IID standard normal variates,\nœÉ is an n-element vector of standard deviations,\nC is obtained from CorrCholesky(n),\n\nthen Diagonal(œÉ) * C.L * z is a zero-centered multivariate normal variate with the standard deviations œÉ and correlation matrix C.L * C.U.\n\n\n\n\n\n","category":"type"},{"location":"#MeasureTheory.LKJCholesky","page":"Home","title":"MeasureTheory.LKJCholesky","text":"LKJCholesky(k=3, Œ∑=1.0)\nLKJCholesky(k=3, logŒ∑=0.0)\n\nLKJCholesky(k, ...) gives the k√ók LKJ distribution (Lewandowski et al 2009) expressed as a Cholesky decomposition. As a special case, for C = rand(LKJCholesky(k=K, Œ∑=1.0)) (or equivalently C=rand(LKJCholesky{k}(k=K, logŒ∑=0.0))), C.L * C.U is uniform over the set of all K√óK correlation matrices. Note, however, that in this case C.L and C.U are not sampled uniformly (because the multiplication is nonlinear).\n\nThe logdensity method for this measure applies for LowerTriangular, UpperTriangular, or Diagonal matrices, and will \"do the right thing\". The logdensity does not check if L*U yields a valid correlation matrix.\n\nValid values are Œ∑  0. When Œ∑  1, the distribution is unimodal with a peak at I, while 0  Œ∑  1 yields a trough. Œ∑ = 2 is recommended as a vague prior.\n\nAdapted from https://github.com/tpapp/AltDistributions.jl\n\n\n\n\n\n","category":"type"},{"location":"#MeasureBase.logdensity","page":"Home","title":"MeasureBase.logdensity","text":"logdensity(Œº::AbstractMeasure [, ŒΩ::AbstractMeasure], x::X)\n\nCompute the logdensity of the measure Œº at the point x. This is the standard way to define logdensity for a new measure. the base measure is implicit here, and is understood to be basemeasure(Œº).\n\n\n\n\n\n","category":"function"},{"location":"#MeasureTheory.asparams","page":"Home","title":"MeasureTheory.asparams","text":"asparams build on TransformVariables.as to construct bijections to the parameter space of a given parameterized measure. Because this is only possible for continuous parameter spaces, we allow constraints to assign values to any subset of the parameters.\n\n\n\nasparams(::Type{<:ParameterizedMeasure}, ::Val{::Symbol})\n\nReturn a transformation for a particular parameter of a given parameterized measure. For example,\n\njulia> asparams(Normal, Val(:œÉ))\nas‚Ñù‚Çä\n\n\n\nasparams(::Type{<: ParameterizedMeasure{N}}, constraints::NamedTuple) where {N}\n\nReturn a transformation for a given parameterized measure subject to the named tuple constraints. For example,\n\njulia> asparams(Binomial{(:p,)}, (n=10,))\nTransformVariables.TransformTuple{NamedTuple{(:p,), Tuple{TransformVariables.ScaledShiftedLogistic{Float64}}}}((p = asùïÄ,), 1)\n\n\n\naspararams(::ParameterizedMeasure)\n\nReturn a transformation with no constraints. For example,\n\njulia> asparams(Normal{(:Œº,:œÉ)})\nTransformVariables.TransformTuple{NamedTuple{(:Œº, :œÉ), Tuple{TransformVariables.Identity, TransformVariables.ShiftedExp{true, Float64}}}}((Œº = as‚Ñù, œÉ = as‚Ñù‚Çä), 2)\n\n\n\n\n\n","category":"function"}]
}
